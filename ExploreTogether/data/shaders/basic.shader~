#version 330 core

layout (location = 0) in vec3  position;
layout (location = 1) in vec2  uv;
layout (location = 2) in float texture;
layout (location = 3) in vec4  color;

out vec4  v_color;
out vec2  v_uv;
out float v_texture;
out vec3  v_position;
out vec4  v_shadow_coord;

uniform mat4 proj_matrix;
uniform mat4 view_matrix;
uniform mat4 model_matrix;

uniform mat4 depth_proj_matrix;
uniform mat4 depth_view_matrix;
uniform mat4 depth_model_matrix;

void main() {
  gl_Position = proj_matrix * view_matrix * model_matrix * vec4(position, 1.0);
  v_color     = color;
  v_uv        = uv;
  v_texture   = texture;
  v_position  = (model_matrix * vec4(position, 1.0)).xyz;
  v_shadow_coord = (depth_proj_matrix * depth_view_matrix * depth_model_matrix) * vec4(position, 1.0);
}

#frag
#version 330 core

out vec4 frag_color;

in vec4  v_color;
in vec2  v_uv;
in float v_texture;
in vec3  v_position;
in vec4  v_shadow_coord;

uniform float 	  ignore_texture;
uniform vec4 	  color_override;
uniform sampler2D texture_diffuse;
uniform sampler2D depth_texture;

uniform vec3  remember_position;
uniform float remember_radius;
uniform float remember_active;

float calculate_shadow(vec4 shadow_coord) {
  vec3 proj_coords = shadow_coord.xyz / shadow_coord.w;
  proj_coords = proj_coords * 0.5 + 0.5;
  float closest_depth = texture(depth_texture, proj_coords.xy).r; 
  float current_depth = proj_coords.z;
    
  float shadow    = 0.0;
  vec2 texel_size = 1.0 / textureSize(depth_texture, 0);
  float bias 	  = 0.005;
  
  for(int x = -1; x <= 1; x++) {
    for(int y = -1; y <= 1; y++) {
      float pcf_depth = texture(depth_texture, proj_coords.xy + vec2(x, y) * texel_size).r; 
      shadow += current_depth - bias > pcf_depth ? 0.5 : 0.0;        
    }    
  }
  shadow /= 9.0;
  return shadow;
}

void main() {
  int texture_id = int(v_texture-1);
  if(texture_id < 0 || ignore_texture == 1.0) {
    frag_color = v_color * color_override;
  } else {
    frag_color = texture(texture_diffuse, v_uv) * v_color;
  }

  if(frag_color.a < 0.5) {
    discard;
  }
  
  float max_radius = remember_radius;
  float min_radius = remember_radius - 0.5;
  float blend_distance = max_radius - min_radius;
  
  if(remember_active == 1.0) {
    float vertex_remember_distance = distance(remember_position, v_position);
    if(vertex_remember_distance < min_radius) {
      // ignore
    } else if(vertex_remember_distance < max_radius) {
      float value     = max_radius - vertex_remember_distance;
      float blend     = mix(1.0, 0.0, value / blend_distance);
      float luminance = (frag_color.r * 0.35 + frag_color.g * 0.71 + frag_color.b * 0.12);
      
      frag_color = vec4(luminance + blend, luminance + blend, luminance + blend, frag_color.a);
    } else {
      discard;
    }
  } else {
    float vertex_remember_distance = distance(remember_position, v_position);
	       
    if(vertex_remember_distance < min_radius) {
      discard;
    } else if(vertex_remember_distance < max_radius) {
      float value 	= max_radius - vertex_remember_distance;
      float blend 	= mix(1.0, 0.0, value / blend_distance);
      float luminance = (frag_color.r * 0.35 + frag_color.g * 0.71 + frag_color.b * 0.12);

      frag_color = vec4(luminance + blend, luminance + blend, luminance + blend, frag_color.a);
    }
    
    // testing shadow
    float shadow = calculate_shadow(v_shadow_coord);
    vec4 light = vec4(1.0 - shadow, 1.0 - shadow, 1.0 - shadow, 1.0);
    frag_color = light * frag_color;
  }
}
